## 推荐列表

src/pages/recommend/index.vue

![image-20230226233630578](https://cdn.jsdelivr.net/gh/zengzjie/picgo-image@main/static_files/image-20230226233630578.png)

布局分析：

```vue
<template>
  <view class="viewport">
    <!-- 广告图 -->
    <view class="cover">
      <image :src="bannerPicture"></image>
    </view>
    <!-- Tabs选项卡 -->
    <view class="tabs">
      <view v-for="key in subTypesMap.keys()" :key="key" class="tabs-item">
        <text :class="['text', activeKey === key ? 'active' : '']" @click="handleSwitchTab(key)">
          {{ subTypesMap.get(key).title }}
        </text>
      </view>
    </view>
    <!-- 滚动列表 - Map下的不同key的列表 -->
    <scroll-view
      v-for="item in subTypesMap.values()"
      v-show="activeKey === item.id"
      :key="item.id"
      class="scroll-view"
      scroll-y
      enhanced
      :show-scrollbar="false"
      lower-threshold="150"
      @scrolltolower="onScrolltolower"
    >
      <view class="goods">
        <navigator
          v-for="goods in item.items"
          :key="goods.id"
          class="navigator"
          hover-class="none"
          :url="`/pages/goods/index?id=${goods.id}`"
        >
          <image :src="goods.picture" mode="aspectFill" class="image"></image>
          <view class="name">{{ goods.name }}</view>
          <view class="price">
            <text class="small">¥</text>
            {{ goods.price }}
          </view>
        </navigator>
      </view>
      <view class="loading-text">
        {{ subTypesMap.get(activeKey)?.finish ? '没有更多了~' : '加载中...' }}
      </view>
    </scroll-view>
  </view>
</template>
```

地址参数：

用户在首页面点击了不同类型的人气推荐之后会跳转到推荐列表页面，并且不同类型的人气推荐在进行链接跳转时在地址中拼凑了 type 参数，根据 type 的值可以区分用户点击的是哪种类型的人气推荐，然后去调用不同的接口获取列表数据，type 取值对应的接口路径如下表所示：

| 推荐类型 | type 值 | 接口路径               |
| -------- | ------- | ---------------------- |
| 特惠推荐 | 1       | /home/preference/mutli |
| 爆款推荐 | 2       | /home/inVogue/mutli    |
| 一站买全 | 3       | /home/oneStop/mutli    |
| 领券中心 | 4       | 未提供                 |
| 新鲜好物 | 5       | /home/new/mutli        |

接口地址：见上表

请求方式：GET

登录权限: 否

请求参数：

**Query:**

| 字段名称 | 是否必须 | 默认值 | 备注                 |
| -------- | -------- | ------ | -------------------- |
| subType  | 否       | 1      | 推荐列表 Tab 项的 id |
| page     | 否       |        | 页码                 |
| pageSize | 否       |        | 每页商品数量         |

成功响应结果：

| 字段名称      | 数据类型 | 备注         |
| ------------- | -------- | ------------ |
| id            | String   | ID           |
| title         | String   | 推荐类型名称 |
| bannerPicture | String   | 图片路径     |
| goodsItems    | Object   | 商品列表数据 |
| subTypes      | Array    | Tab 相关数据 |

**goodsItems**

| 字段名称 | 数据类型 | 备注         |
| -------- | -------- | ------------ |
| items    | Array    | 商品列表     |
| counts   | Number   | 全部商品数量 |
| page     | Number   | 当前页码     |
| pages    | Number   | 总页码数量   |
| pageSize | Number   | 每页商品数量 |

**subTypes**

| 字段名称 | 数据类型 | 备注     |
| -------- | -------- | -------- |
| id       | String   | ID       |
| title    | String   | Tab 名称 |

```tsx
/**
 * 特惠推荐
 * @param
 */
export function getHomeRecommend(url: string, data: RecommendData) {
  return http<RecommendResult>({
    method: 'GET',
    url: url,
    data
  });
}
```

页面的 `tabs` 数据用了 `Map` 的结构去存储，在 `onLoad` 中去找到当前传入的 `type` 类型并找到其映射的请求地址请求获取到数据后，通过 `uni.setNavigationBarTitle({title})` 设置标题，遍历 `subTypes` 然后匹配 `goodsItems` ，判断其 `pages` 是否等于1，如果等于1则以 `id` 为 key，将其自身的数据和 `goodsItems` 匹配的数据合并并且添加上 `finish` 为true，`scrollTop: 0` ，否则 `finish` 为false，代表则数据还可以滚动加载。

```tsx
let currUrl = '';
onLoad(async () => {
  const currUrlMap = urlMap.find((item) => item.type === props.type);
  if (currUrlMap) {
    // 保存当前url
    currUrl = currUrlMap.url;
    const { subTypes, goodsItems, bannerPicture: picture, title } = await getHomeRecommend(currUrlMap.url, {});
    subTypes?.forEach((item: SubType, index: number) => {
      if (goodsItems?.[item.id].pages === 1) {
        subTypesMap.set(item.id, { ...item, ...goodsItems?.[item.id], finish: true, scrollTop: 0 });
      } else {
        subTypesMap.set(item.id, { ...item, ...goodsItems?.[item.id], finish: false, scrollTop: 0 });
      }
    });
    // 动态更新导航标题
    uni.setNavigationBarTitle({
      title
    });
    // 设置广告图
    bannerPicture.value = picture;
    // 设置高亮的下标
    activeKey.value = subTypesMap.keys().next().value || '';
  }
});

// 滚动到底部触发
const onScrolltolower = async () => {
  const currSubTypes = subTypesMap.get(activeKey.value);
  // 判断是否已经加载完毕
  if (currSubTypes.finish) {
    uni.showToast({
      title: '没有更多了~',
      icon: 'none'
    });
    return;
  }

  let result: RecommendResult = {
    bannerPicture: '',
    title: '',
    id: ''
  };

  // hack: scroll-view 组件在滚动到底部的时，有时候不会会触发 onScrolltolower 事件，所以这里做了一个 hack
  if (parametersPage.page >= currSubTypes.pages) {
    currSubTypes.finish = true;
    return;
  } else {
    parametersPage.page++;
    // 请求下一页数据
    result = await getHomeRecommend(currUrl, {
      subType: currSubTypes.id,
      page: parametersPage.page,
      pageSize: 10
    });
  }

  // 拿到下一页的 items 数据
  const items = result.goodsItems?.[currSubTypes.id].items as Goods[];

  // 追加到对应 activeKey 的 Map 中
  subTypesMap.set(activeKey.value, {
    ...currSubTypes,
    items: [...currSubTypes.items, ...items]
  });
};
```

