# 创建以 typescript 开发的工程  

```shell
npx degit dcloudio/uni-preset-vue#vite-ts vue3-vite-fresh_rabbit
```

```shell
// 进入项目工程
cd vue3-vite-fresh_rabbit
// 安装依赖
yarn

// 运行项目
yarn dev:mp-weixin
```

❗️如果发现运行了项目后终端输出的内容如下：

![image-20230226221407823](https://cdn.jsdelivr.net/gh/zengzjie/picgo-image@main/static_files/image-20230226221407823.png)

其实这样项目是已经启动起来了，只是看不到我们熟悉的Ip地址信息

只需要在 `package.json` 中的 `dev:h5` 后面加上 `info` ：`"dev:h5": "uni -l info"`

### 1. 组件库

组件 - 扩展组件（uni-ui）

安装 `sass`

```shell
yarn add sass -D
```

安装 `uni-ui`

```shell
yarn add @dcloudio/uni-ui
```

配置 `easycom` 

```
// pages.json
{
	// 组件自动引入规则
  "easycom": {
    "autoscan": true,
    "custom": {
      // 安装 uni-ui 组件库步骤：
      //   1. 安装 sass： 参考命令 pnpm i sass -D
      //   2. 安装 uni-ui：参考命令 pnpm i @dcloudio/uni-ui
      //   3. 配置 easycom 组件自动导入规则
      //   4. 配置 vite.config.ts
      //   5. 使用 组件库
      // uni-ui 规则如下配置
      "^uni-(.*)": "@dcloudio/uni-ui/lib/uni-$1/uni-$1.vue"
    }
  }
}
```

在 `template` 中使用组件：

```vue
<uni-badge text="1"></uni-badge>
<uni-badge text="2" type="success"></uni-badge>
<uni-badge text="3" type="primary" :inverted="true"></uni-badge>
```

❗️使用 yarn 或者 npm 安装的组件，默认情况下 `babel-loader` 会忽略所有 `node_modules` 中的文件，导致条件编译失效，需要通过配置 `vite.config.ts` 解决：

```tsx
export default defineConfig({
  // 依赖预构建
    optimizeDeps: {
      entries: ['@dcloudio/uni-ui']
    }
})
```

`vite.config.ts` 相关配置

```tsx
import { defineConfig, loadEnv, UserConfig } from 'vite';
import * as path from 'path';
import uni from '@dcloudio/vite-plugin-uni';

// https://vitejs.dev/config/
export default defineConfig(({ command, mode }) => {
  const env = loadEnv(mode, process.cwd());

  const config: UserConfig = {
    plugins: [uni()],
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src')
      }
    },
    css: {
      preprocessorOptions: {
        // 统一引入公共颜色变量文件，可在全局中直接使用
        scss: { charset: false, additionalData: `@import "@/styles/variables.scss";` }
      }
    },
    // 依赖预构建
    optimizeDeps: {
      entries: ['@dcloudio/uni-ui']
    }
  };

  if (command === 'serve') {
    // 开发
    return config;
  } else {
    // 生产
    return config;
  }
});

```



### 2. 接口文档 & 规范

接口文档地址： [https://www.apifox.cn/apidoc/shared-0e6ee326-d646-41bd-9214-29dbf47648fa](https://gitee.com/link?target=https%3A%2F%2Fwww.apifox.cn%2Fapidoc%2Fshared-0e6ee326-d646-41bd-9214-29dbf47648fa)

接口服务器基地址为: [https://pcapi-xiaotuxian-front-devtest.itheima.net](https://gitee.com/link?target=https%3A%2F%2Fpcapi-xiaotuxian-front-devtest.itheima.net)

#### 2.1 请求规范

调用接口发出请求时，请求参数的类型有多种类型，我们有必要了解不同类型参数的含义及其在小程序的使用，类型如下表所示：

| 参数类型 | 含义                  | 说明                         |
| -------- | --------------------- | ---------------------------- |
| query    | 请求地址 ? 后面的参数 | 小程序中通过 data 进行设置   |
| body     | 请求主体中的参数      | 小程序中通过 data 进行设置   |
| headers  | 请求头中的参数        | 小程序中通过 header 进行设置 |

在小程序中不同类型参数的使用示例如下：

```tsx
uni.request({
  url: '',
  method: 'GET',
  // header 类型参数使用 header 进行传递
  header: {
    Authorization: 'Bearer 45sdxzfdkffdfs43...'
  },
  // 无论是 query 或是 body 类型参数均使用 data 进行传递
  data: {
    id: '435754'
  }
})
```

**在小程序中无论是 query 或是 body 类型的参数均使用 data 进行传递，headers 类型的参数使用 header 进行传递。**

#### 2.2 响应规范

在调用接口后响应的数据中会包含一些固定的字段，分成功和失败两种情形：

调用接口成功时包含的字段为：

| 字段名称 | 含义         | 示例     |
| -------- | ------------ | -------- |
| msg      | 成功提示信息 | 操作成功 |
| result   | 数据结果     |          |

### 3. 封装 `uni.request`

```tsx
// 首选服务器
const baseUrl = 'https://pcapi-xiaotuxian-front-devtest.itheima.net';

// 备选服务器
const backupUrl = 'https://pcapi-xiaotuxian-front.itheima.net';

// https://uniapp.dcloud.net.cn/api/interceptor.html#
// 抽离拦截器配置 request 和 uploadFile 复用
const httpInterceptor = {
  // 拦截前触发
  invoke(args: UniApp.RequestOptions) {
    // 如果不是 http 开头的，我们才需要进行 URL 拼接
    if (args.url.startsWith('http') === false) {
      // request 触发前拼接 url
      args.url = baseUrl + args.url;
    }
    // 小程序端调用，请求头中header中必须添加：source-client：miniapp
    args.header = {
      ...args.header,
      'source-client': 'miniapp' // 添加小程序端调用标识
    };
    // 在非vue文件中，哪里使用 store 就哪里调用
    const memberStore = useMemberStore();
    // 获取token
    const token = memberStore.profile.token;
    // 如果有token，就添加到请求头中
    if (token) {
      args.header.Authorization = token;
    }
  }
};

// 需要添加刚刚写拦截器，拦截 request
uni.addInterceptor('request', httpInterceptor);
// 拦截 uploadFile
uni.addInterceptor('uploadFile', httpInterceptor);

interface ApiREsponse {
  // 业务状态码
  code: string;
  // 响应数据
  result: any;
  // 响应信息
  msg: string;
  // 错误信息
  message?: string;
}

/**
 * @description: 封装通过的请求 http 方法
 * @param {string} options 请求参数
 * @return {*}
 */

export function http<T>(options: UniApp.RequestOptions) {
  // 返回 Promise 对象
  // Promise 的泛型用于确认 resolve 的类型
  return new Promise<T>((resolve, reject) => {
    uni.request({
      // 应用所有的参数
      ...options,
      // success 成功回调
      // 🚨 uni.request 和 axios 的请求成功回调参数不一样：
      // 1. 小程序中 uni.request 收到服务端响应后就代表成功，不管状态码是多少
      // 2. 网页端 axios 收到服务端响应后，只有状态码是 2xx 才代表成功，其他状态码都是失败
      success: (res) => {
        // 业务状态码
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve((res.data as ApiREsponse).result);
        } else if (res.statusCode === 401) {
          // 未登录
          uni.navigateTo({
            url: '/pages/login/index'
          });
          // 标记为失败
          reject(res);
        } else {
          console.log(' ❌失败', res);
          // 通知错误提示
          uni.showToast({
            icon: 'none',
            title: (res.data as ApiREsponse).message || '请求失败'
          });
          // 🎯 标记为失败：reject 可让 await 后面的代码不执行，更符合编程逻辑
          reject(res);
        }
      },
      // 失败（网络）
      fail: (err) => {
        reject(err);
      }
    });
  });
}

// 也可以使用 axios 去封装, 使用 adapter 适配小程序
// const http = axios.create({
//   baseURL,
//   withCredentials: true,
//   timeout: 5000
// });

// http.defaults.addpter = function (config: any) {
//   // 返回 Promise
//   return new Promise(( resolve, reject ) => {});
// };

// export { http };
```

### 4.  `main.ts` 

这里我主要做了将一些常用到的状态变量都挂载到全局下，这样在每个页面中都只需要去通过调用 `getcurrentInstance()` 去获取，将常用的工具函数都在 `main` 下使用 use 去注册使用（也是通过调用 `getcurrentInstance()` ）

```tsx
import { createSSRApp } from 'vue';
import App from './App.vue';
import pinia from './stores';
import xUtils from './utils';

export function createApp() {
  const app = createSSRApp(App);
  // 挂载 lodash 到全局
  app.config.globalProperties.$_ = _;
  uni.getSystemInfo({
    success: function (e: any) {
      // 挂载到全局中，通过 const { proxy, ctx } = getcurrentInstance(); 获取，建议使用 proxy 去获取挂载的属性，ctx 打包后内容可能拿不到
      // #ifndef MP
      app.config.globalProperties.$StatusBar = e.statusBarHeight;
      if (e.platform == 'android') {
        app.config.globalProperties.$CustomBar = e.statusBarHeight + 50;
      } else {
        app.config.globalProperties.$CustomBar = e.statusBarHeight + 45;
      }
      // #endif

      // #ifdef MP-WEIXIN
      app.config.globalProperties.$StatusBar = e.statusBarHeight;
      const custom = uni.getMenuButtonBoundingClientRect();
      app.config.globalProperties.$Custom = custom;
      app.config.globalProperties.$CustomBar = custom.bottom + custom.top - e.statusBarHeight;
      // #endif

      //窗口高度
      app.config.globalProperties.$windowHeight = e.windowHeight;
      //获取导航高度
      app.config.globalProperties.$navHeight = e.statusBarHeight * (750 / e.windowWidth) + 91;
      // 在竖屏正方向下的安全区域插入位置
      app.config.globalProperties.$safeAreaInsets = e.safeAreaInsets;
      app.config.globalProperties.$SystemInfo = e;
    }
  });
  app.use(pinia);
  app.use(xUtils);

  return {
    app
  };
}

```

